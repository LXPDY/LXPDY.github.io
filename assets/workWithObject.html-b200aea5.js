import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as p,c as l,b as s,a,w as r,d as n,f as e}from"./app-490f74f1.js";const u={},d=s("h1",{id:"working-with-objects-使用对象",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#working-with-objects-使用对象","aria-hidden":"true"},"#"),n(" Working with Objects 使用对象")],-1),m=s("p",null,"Objective-C 应用程序中的大部分工作是通过在对象生态系统中来回发送消息来完成的。【苹果好几次提到这句话了】这些对象中的一些是由Cocoa或Cocoa Touch提供的框架类的实例，另一些是你自己编写的类的实例。",-1),v=s("strong",null,"动态特性",-1),k=s("code",null,"dynamic typing",-1),b=e(`<p>在对象可以被使用之前，程序员必须正确地创建它:做好为其分配内存，为其属性<code>properties</code>和任何必要的内部值进行初始化等一系列动作。本章将描述如何嵌套调用以分配和初始化对象，以确保对象被正确配置。</p><h2 id="objects-send-and-receive-messages-对象发送和接收消息" tabindex="-1"><a class="header-anchor" href="#objects-send-and-receive-messages-对象发送和接收消息" aria-hidden="true">#</a> Objects Send and Receive Messages 对象发送和接收消息</h2><p>尽管在Objective-C中发送对象之间的消息有几种不同的方法，但远远最常见的方法是使用方括号的基本语法，如下所示：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token punctuation">[</span>someObject doSomething<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>左边的引用（someObject），是消息的接收者。右边的消息（doSomething）是要在该接收者上调用的方法的名称。换句话说，当执行上面的代码行时，someObject将会收到doSomething消息。</p><p>上一章描述了如何创建类的接口以及如何创建该类的实现,如下所示：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> XYZPerson <span class="token punctuation">:</span> NSObject
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>sayHello<span class="token punctuation">;</span>
<span class="token keyword">@end</span>
  
<span class="token keyword">@implementation</span> XYZPerson
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>sayHello <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;Hello, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>注意：此示例使用了Objective-C字符串literal简写@&quot;Hello, world!&quot;。字符串是Objective-C中允许使用简写literal语法的多种类型之一。@&quot;Hello, world!&quot;在概念上等同于说“一个代表字符串Hello, world!的Objective-C字符串对象”。
literal和对象创建在本章的后面“ Objects Are Created Dynamically 对象是动态创建的”中进一步解释。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>假设你已经获得了一个XYZPerson对象，你可以这样向它发送sayHello消息：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code> <span class="token punctuation">[</span>somePerson sayHello<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>发送Objective-C消息在概念上非常类似于调用C函数。下图显示了sayHello消息的有效程序流程。</p><figure><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Art/programflow1.png" alt=" Basic messaging program flow" tabindex="0" loading="lazy"><figcaption> Basic messaging program flow</figcaption></figure><p>为了指定消息的接收者，重要的是要理解在Objective-C中<strong>如何使用指针来引用对象</strong>。</p><h3 id="use-pointers-to-keep-track-of-objects-使用指针跟踪对象" tabindex="-1"><a class="header-anchor" href="#use-pointers-to-keep-track-of-objects-使用指针跟踪对象" aria-hidden="true">#</a> Use Pointers to Keep Track of Objects 使用指针跟踪对象</h3><p>C语言和Objective-C使用变量来跟踪值，就像大多数其他编程语言一样。标准C语言中定义了一些基本的标量变量类型，包括整数、浮点数和字符，可以像这样声明并分配值：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> someInteger <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> someFloatingPointNumber <span class="token operator">=</span> <span class="token number">3.14f</span><span class="token punctuation">;</span>
<span class="token comment">//局部变量，也就是在方法或函数中声明的变量，像这样：</span>
<span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>myMethod <span class="token punctuation">{</span>
	<span class="token keyword">int</span> someInteger <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//在此示例中，someInteger被声明为myMethod内部的局部变量；</span>
<span class="token comment">//一旦执行到方法的右大括号，someInteger将不再可访问。</span>
<span class="token comment">//当局部标量变量（例如int或float）消失时，其值也会消失。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>与此不同</strong>，Objective-C对象通常以稍微不同的方式分配**。对象通常的生命周期要长于方法调用的简单范围**。特别表现在通常一个对象的寿命<strong>比用于跟踪它的原始变量的寿命更长</strong>，因此<strong>对象的内存是动态分配和释放的</strong>。【“亿”点不同】</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>注意：如果你习惯使用栈stack和堆heap等术语，
局部变量是在栈stack上分配的，而对象是在堆上分配的。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这需要你使用C指针（用于保存内存地址）来跟踪它们在内存中的位置，像这样：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>myMethod <span class="token punctuation">{</span>
    NSString <span class="token operator">*</span>myString <span class="token operator">=</span> <span class="token comment">// get a string from somewhere...</span>
    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>尽管指针变量myString（星号表示它是一个指针）【苹果它真的担心你看不懂】的范<strong>围仅限于myMethod的范围</strong>，但<strong>它实际上指向内存中的字符串对象可能在该范围之外存在更长的时间</strong>。举个例子，它不仅可能已经存在，或者你可能需要传递对象以在其他地方调用它的方法。【这里就已经和C++的对象不大一样了，C++对象的生命周期由程序员或者指南指针严格控制】</li></ul><h3 id="you-can-pass-objects-for-method-parameters-可以将对象作为方法参数传递" tabindex="-1"><a class="header-anchor" href="#you-can-pass-objects-for-method-parameters-可以将对象作为方法参数传递" aria-hidden="true">#</a> You Can Pass Objects for Method Parameters 可以将对象作为方法参数传递</h3><p>如果需要在发送消息时传递对象，可以在方法参数中提供对象指针。因此，声明接受字符串对象的方法的语法如下：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>saySomething<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>greeting<span class="token punctuation">;</span>
<span class="token comment">//可以像这样实现saySomething:方法：</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>saySomething<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>greeting <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>greeting指针的行为类似于局部变量，仅限于saySomething:方法的范围**，即使它指向的实际字符串对象在调用方法之前存在，并且在方法完成后继续存在**。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>注意：NSLog()使用格式说明符来指示替代标记，就像C标准库printf()函数一样。
打印Log到控制台的字符串是通过合并字符串（第一个参数）以及后续插入的值（其余参数）
所形成结果得到的。

Objective-C中还提供了一个附加的替代标记，%@，用于表示对象。在运行时，
此说明符将被替换为调用所提供对象的descriptionWithLocale:方法（如果存在）
或description方法的结果。description方法由NSObject实现，返回对象的类
以及对象的内存地址，但许多Cocoa和Cocoa Touch类会覆盖它以提供更有用的信息。
对于NSString，description方法只是返回它表示的字符串。

有关在NSLog()和NSString类中可用的格式说明符的更多信息，请参阅文章字符串格式说明符。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,26),g={href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Strings/Articles/formatSpecifiers.html#//apple_ref/doc/uid/TP40004265",target:"_blank",rel:"noopener noreferrer"},h=e(`<h3 id="methods-can-return-values-方法可以返回值" tabindex="-1"><a class="header-anchor" href="#methods-can-return-values-方法可以返回值" aria-hidden="true">#</a> Methods Can Return Values 方法可以返回值</h3><p>除了通过方法参数传递值之外，方法还可以返回值。到目前为止，在本章中显示的每个方法的返回类型都是void。C的void关键字表示方法不返回任何内容。</p><p>指定返回类型为int表示该方法返回一个标量整数值：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>magicNumber<span class="token punctuation">;</span>
<span class="token comment">//方法的实现使用C的return语句来指示方法完成后应返回的值，如下所示：</span>
<span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>magicNumber <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不需要跟踪方法返回的值，可以像这样调用方法，即使magicNumber方法除了返回一个值之外不执行任何有用的操作也没有问题：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code> <span class="token punctuation">[</span>someObject magicNumber<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//如果需要跟踪返回的值，可以声明一个变量并将其分配给方法调用的结果，像这样：</span>
 <span class="token keyword">int</span> interestingNumber <span class="token operator">=</span> <span class="token punctuation">[</span>someObject magicNumber<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你也可以以类似的方式从方法返回对象。例如，NSString类提供了一个uppercaseString方法：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>uppercaseString<span class="token punctuation">;</span>
<span class="token comment">//使用方法返回标量值的方式一样，它需要使用指针来跟踪结果：</span>
  NSString <span class="token operator">*</span>testString <span class="token operator">=</span> <span class="token string">@&quot;Hello, world!&quot;</span><span class="token punctuation">;</span>
  NSString <span class="token operator">*</span>revisedString <span class="token operator">=</span> <span class="token punctuation">[</span>testString uppercaseString<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//当此方法调用返回时，revisedString将指向一个NSString对象，表示HELLO WORLD!的字符。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请记住，当实现方法以返回对象时，如下所示：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>magicString <span class="token punctuation">{</span>
    NSString <span class="token operator">*</span>stringToReturn <span class="token operator">=</span> <span class="token comment">// create an interesting string...</span>
 
    <span class="token keyword">return</span> stringToReturn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即使stringToReturn指针超出范围，作为返回值传递时，<strong>字符串对象仍将存在</strong>。【前面提到的生命周期的不同在这里得到体现】</p><p>在这种情况下，存在一些内存管理考虑因素：返回的对象（在堆上被创建）需要在原始调用方法被使用足够长时间，不过不是永远——因为那会导致内存泄漏。在很大程度上，Objective-C编译器的自动引用计数（ARC）特性会为你处理这些考虑因素。【这里居然不贴个ARC机制的解释文章】</p><h3 id="objects-can-send-messages-to-themselves-对象可以向自己发送消息" tabindex="-1"><a class="header-anchor" href="#objects-can-send-messages-to-themselves-对象可以向自己发送消息" aria-hidden="true">#</a> Objects Can Send Messages to Themselves 对象可以向自己发送消息</h3><p>无论在什么时候编写方法的实现，都可以访问一个重要的隐藏值:<code>self</code>。从概念上讲，<code>self</code>是引用“接收到此消息的对象”的一种方式。它是一个指针，就像上面的greeting值一样，<strong>可以用于在当前接收对象上调用方法</strong>。</p><p>你可能决定通过修改sayHello方法，让它使用本章中提到的的saySomething:方法，从而将NSLog()的调用移到单独的方法中。这意味着你可以添加其他方法，例如sayGoodbye，它们都可以调用saySomething:方法来处理实际的问候过程。如果以后要在用户界面中显示每个问候语，只需修改saySomething:方法，而无需逐个调整每个问候方法。</p><p>使用<code>self</code>来调用当前对象上的消息的新实现如下：【也就是给自己套一层娃实现代码复用】</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@implementation</span> XYZPerson
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>sayHello <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> saySomething<span class="token punctuation">:</span><span class="token string">@&quot;Hello, world!&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>saySomething<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>greeting <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果发送给XYZPerson对象sayHello消息，那么更新后的实现将如下图所示的有效程序流程一样。</p><figure><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Art/programflow2.png" alt="Program flow when messaging self" tabindex="0" loading="lazy"><figcaption>Program flow when messaging self</figcaption></figure><h3 id="objects-can-call-methods-implemented-by-their-superclasses-对象可以调用其超类实现的方法" tabindex="-1"><a class="header-anchor" href="#objects-can-call-methods-implemented-by-their-superclasses-对象可以调用其超类实现的方法" aria-hidden="true">#</a> Objects Can Call Methods Implemented by Their Superclasses 对象可以调用其超类实现的方法</h3><p>Objective-C中还有一个重要的关键字可供使用，称为<code>super</code>。<strong>向</strong><code>super</code><strong>发送消息</strong>是调用<strong>继承链中</strong>更高级别的超类定义的方法的一种方法。最常见的使用super是在重写<code>overriding</code>方法时。</p><p>假设你想创建一种新类型的人类【<s>New type（无端联想）</s>】，一种“大声喊话的人”类，其中每个问候都以大写字母显示。你可以复制整个XYZPerson类并把每个方法中的每个字符串修改成大写形式。但最简单的方法是创建一个继承自XYZPerson的新类，并只重写<code>overriding</code> saySomething:方法以将问候以大写字母显示，如下所示：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@interface</span> XYZShoutingPerson <span class="token punctuation">:</span> XYZPerson
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> XYZShoutingPerson
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>saySomething<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>greeting <span class="token punctuation">{</span>
    NSString <span class="token operator">*</span>uppercaseGreeting <span class="token operator">=</span> <span class="token punctuation">[</span>greeting uppercaseString<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@&quot;%@&quot;</span><span class="token punctuation">,</span> uppercaseGreeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该示例声明了一个额外的字符串指针uppercaseGreeting，并将其分配了从原始greeting对象发送uppercaseString消息的返回值。正如你前面看到的，这将是一个新的字符串对象，将原始字符串中的每个字符转换为大写字母。</p><p>因为sayHello由XYZPerson实现，并且XYZShoutingPerson设置为继承自XYZPerson，所以你也可以在XYZShoutingPerson对象上调用sayHello。当你在XYZShoutingPerson上调用sayHello时，[self saySomething:...]将使用被重写的实现，并以大写字母显示问候，结果如下图所示的有效程序流程。</p><figure><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Art/programflow3.png" alt="Program flow for an overridden method" tabindex="0" loading="lazy"><figcaption>Program flow for an overridden method</figcaption></figure><p>然而，新实现并不理想，因为如果以后决定修改XYZPerson的saySomething:实现，以便在用户界面元素中显示问候时不采用NSLog()，那么还需要修改XYZShoutingPerson的实现。</p><p>更好的方法是将XYZShoutingPerson的saySomething:版本更改为调用超类（XYZPerson）实现来处理实际问候：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">@implementation</span> XYZShoutingPerson
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>saySomething<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>greeting <span class="token punctuation">{</span>
    NSString <span class="token operator">*</span>uppercaseGreeting <span class="token operator">=</span> <span class="token punctuation">[</span>greeting uppercaseString<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span><span class="token keyword">super</span> saySomething<span class="token punctuation">:</span>uppercaseGreeting<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">@end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，当发送一个XYZShoutingPerson对象sayHello消息时，将产生下图所示的有效程序流程。</p><figure><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Art/programflow4.png" alt="Program flow when messaging super" tabindex="0" loading="lazy"><figcaption>Program flow when messaging super</figcaption></figure><h2 id="objects-are-created-dynamically-对象是动态创建的" tabindex="-1"><a class="header-anchor" href="#objects-are-created-dynamically-对象是动态创建的" aria-hidden="true">#</a> Objects Are Created Dynamically 对象是动态创建的</h2><p>正如本章之前所述，为Objective-C对象分配内存的行为是动态的。创建对象的第一步是确保为对象的类定义的属性分配足够的内存，同时也包括其继承链上每个超类定义的属性。</p><p>NSObject根类提供了一个<strong>类方法</strong>，<code>alloc</code>，来为你处理这个过程：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">+</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>alloc<span class="token punctuation">;</span><span class="token comment">//这里是类方法</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,35),j=s("strong",null,"它是一个指向对象的指针",-1),S=s("strong",null,"但特殊之处在于它不使用星号",-1),y={href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithObjects/WorkingwithObjects.html#//apple_ref/doc/uid/TP40011210-CH4-SW18",target:"_blank",rel:"noopener noreferrer"},f=e(`<p><code>alloc</code>方法还有另一个重要任务，那就是通过将属性的内存清零来初始化为对象分配的内存。这避免了通常情况下内存中包含来自之前存储的垃圾的问题，但这不足以完全初始化对象。</p><p>需要将<code>alloc</code>方法的调用与init方法的调用组合在一起，<code>init</code>是NSObject的另一个方法：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>init<span class="token punctuation">;</span><span class="token comment">//这里是对象方法</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>init</code>方法<strong>用于确保在创建对象时，它的属性具有合适的初始值</strong>，下一章会对它进行了更详细的讨论。</p><p>请注意，<code>init</code>也返回<code>id</code>。</p><p>如果一个方法返回一个对象指针，<strong>就可以像下面这样将调用嵌套为另一个方法的调用</strong>，从而将多个消息调用组合在一个语句中。正确分配和初始化对象的方法是将alloc调用嵌套在init调用中，如下所示：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>NSObject <span class="token operator">*</span>newObject <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSObject alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>【终于出现了，这一串的含义】</p><p>此示例将newObject变量设置为指向一个新创建的NSObject实例。</p><p>首先执行最内部的调用，因此NSObject类将发送<code>alloc</code>消息，该消息<strong>返回一个新分配的NSObject实例</strong>。然后将返回的对象用作<strong>init消息的接收者</strong>，<strong>init消息本身将对象返回以分配给newObject指针</strong>，如下图所示。</p><figure><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Art/nestedallocinit.png" alt="Nesting the alloc and init message" tabindex="0" loading="lazy"><figcaption>Nesting the alloc and init message</figcaption></figure><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>请注意：使用init返回与alloc创建的对象不同的对象是可能的，
因此最佳的方法是上面所展示的嵌套调用。
如果不给初始化的对象分配指针，请不要初始化对象。例如，不要这样做：
NSObject <span class="token operator">*</span>someObject <span class="token operator">=</span> <span class="token punctuation">[</span>NSObject alloc<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>someObject init<span class="token punctuation">]</span><span class="token punctuation">;</span>
如果init调用返回的是另一个对象，
那么你将会得到一个指向最初分配但没有初始化的对象的指针。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="initializer-methods-can-take-arguments-初始化方法可以接受参数" tabindex="-1"><a class="header-anchor" href="#initializer-methods-can-take-arguments-初始化方法可以接受参数" aria-hidden="true">#</a> Initializer Methods Can Take Arguments 初始化方法可以接受参数</h3><p>有些对象需要使用所需的值进行初始化。例如，NSNumber对象必须使用它需要表示的数值创建。</p><p>NSNumber类定义了几个初始化方法，包括：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>initWithBool<span class="token punctuation">:</span><span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>value<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>initWithFloat<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>initWithInt<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>initWithLong<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用带有参数的初始化方法与普通的init方法是一样的，NSNumber对象是这样分配和初始化的：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>NSNumber <span class="token operator">*</span>magicNumber <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSNumber alloc<span class="token punctuation">]</span> initWithInt<span class="token punctuation">:</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="class-factory-methods-are-an-alternative-to-allocation-and-initialization-类工厂方法是用来创建对象的替代方法" tabindex="-1"><a class="header-anchor" href="#class-factory-methods-are-an-alternative-to-allocation-and-initialization-类工厂方法是用来创建对象的替代方法" aria-hidden="true">#</a> Class Factory Methods Are an Alternative to Allocation and Initialization 类工厂方法是用来创建对象的替代方法</h3><p>如前一章所述，一个类还可以定义<strong>工厂方法</strong><code>factory methods</code>。工厂方法提供了传统的<code>alloc] init]</code>过程的替代方法，这样无需嵌套两个方法。</p><p>NSNumber<strong>类</strong>定义了几个与其初始化方法相匹配的类工厂方法，包括：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token operator">+</span> <span class="token punctuation">(</span>NSNumber <span class="token operator">*</span><span class="token punctuation">)</span>numberWithBool<span class="token punctuation">:</span><span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>value<span class="token punctuation">;</span>
<span class="token operator">+</span> <span class="token punctuation">(</span>NSNumber <span class="token operator">*</span><span class="token punctuation">)</span>numberWithFloat<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span>
<span class="token operator">+</span> <span class="token punctuation">(</span>NSNumber <span class="token operator">*</span><span class="token punctuation">)</span>numberWithInt<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span>
<span class="token operator">+</span> <span class="token punctuation">(</span>NSNumber <span class="token operator">*</span><span class="token punctuation">)</span>numberWithLong<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工厂方法的使用方式如下:</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>  NSNumber <span class="token operator">*</span>magicNumber <span class="token operator">=</span> <span class="token punctuation">[</span>NSNumber numberWithInt<span class="token punctuation">:</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它的<strong>效率</strong>使用alloc和init来创建对象与之前的示例使用<code>alloc] initWithInt:]</code>是<strong>相同</strong>的。类工厂方法通常只是直接调用<code>alloc</code>和相关的<code>init</code>方法，提供了<strong>便利性</strong>。</p><h3 id="use-new-to-create-an-object-if-no-arguments-are-needed-for-initialization-使用new来创建对象-如果不需要初始化参数" tabindex="-1"><a class="header-anchor" href="#use-new-to-create-an-object-if-no-arguments-are-needed-for-initialization-使用new来创建对象-如果不需要初始化参数" aria-hidden="true">#</a> Use new to Create an Object If No Arguments Are Needed for Initialization <strong>使用new来创建对象，如果不需要初始化参数</strong></h3><p>还可以使用<code>new</code>这个类方法来创建类的实例。<strong>这个方法由NSObject提供</strong>【所以说它这个new和C++里的是两个东西】，不需要在你自己的子类中覆盖。</p><p>这实际上与不带参数调用<code>alloc</code>和<code>init</code>是相同的：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>  XYZObject <span class="token operator">*</span>object <span class="token operator">=</span> <span class="token punctuation">[</span>XYZObject new<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// is effectively the same as:</span>
  XYZObject <span class="token operator">*</span>object <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>XYZObject alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="literals-offer-a-concise-object-creation-syntax-使用literals提供简洁的对象创建语法" tabindex="-1"><a class="header-anchor" href="#literals-offer-a-concise-object-creation-syntax-使用literals提供简洁的对象创建语法" aria-hidden="true">#</a> Literals Offer a Concise Object-Creation Syntax <strong>使用Literals提供简洁的对象创建语法</strong></h3><p>一些类允许您使用更简洁的<code>Literal</code>语法来创建实例。【这个<code>Literals</code>我实在不知道怎么翻译了】</p><p>例如，您可以使用特殊的<code>literal</code>表示法来创建一个NSString实例，如下：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>NSString <span class="token operator">*</span>someString <span class="token operator">=</span> <span class="token string">@&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这实际上与分配和初始化一个NSString（或使用其中一个类工厂方法）是相同的：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>  NSString <span class="token operator">*</span>someString <span class="token operator">=</span> <span class="token punctuation">[</span>NSString stringWithCString<span class="token punctuation">:</span><span class="token string">&quot;Hello, World!&quot;</span>
                                              encoding<span class="token punctuation">:</span>NSUTF8StringEncoding<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>NSNumber类还允许很多其他各种<code>literal</code>【发现了它们的特征都是带@】</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>    NSNumber <span class="token operator">*</span>myBOOL <span class="token operator">=</span> <span class="token operator">@</span>YES<span class="token punctuation">;</span>
    NSNumber <span class="token operator">*</span>myFloat <span class="token operator">=</span> <span class="token operator">@</span><span class="token number">3.14f</span><span class="token punctuation">;</span>
    NSNumber <span class="token operator">*</span>myInt <span class="token operator">=</span> <span class="token operator">@</span><span class="token number">42</span><span class="token punctuation">;</span>
    NSNumber <span class="token operator">*</span>myLong <span class="token operator">=</span> <span class="token operator">@</span><span class="token number">42L</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样，这些示例中的每一个都实际上等同于使用相关的初始化调用或类工厂方法。</p><p>您还可以使用包装表达式<code>boxed expression</code>创建NSNumber，如下所示：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>NSNumber <span class="token operator">*</span>myInt <span class="token operator">=</span> <span class="token operator">@</span><span class="token punctuation">(</span><span class="token number">84</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//在这种情况下，表达式会被分析，并创建一个带有结果的NSNumber实例。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,40),N=s("code",null,"literals",-1),w={href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/FoundationTypesandCollections/FoundationTypesandCollections.html#//apple_ref/doc/uid/TP40011210-CH7-SW1",target:"_blank",rel:"noopener noreferrer"},O=e(`<h2 id="objective-c-is-a-dynamic-language-objective-c-是一种动态语言" tabindex="-1"><a class="header-anchor" href="#objective-c-is-a-dynamic-language-objective-c-是一种动态语言" aria-hidden="true">#</a> Objective-C Is a Dynamic Language <strong>Objective-C 是一种动态语言</strong></h2><p>正如前面提到的，您需要使用指针来跟踪内存中的对象。由于Objective-C的动态特性，您<strong>使用的指针的具体类类型并不重要</strong>——当您发送消息时，相关对象上将始终调用正确的方法。</p><p><code>id</code>类型定义了一个<strong>通用对象指针</strong>。在声明变量时使用<code>id</code>是可能的，但您会失去关于对象的编译时<code>*compile*-time </code>信息。</p><p>思考以下代码：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>    id someObject <span class="token operator">=</span> <span class="token string">@&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>someObject removeAllObjects<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种情况下，<code>someObject</code>将指向一个NSString实例，但编译器对该实例一无所知，只知道它是某种类型的对象。<code>removeAllObjects</code>消息只由某些Cocoa或Cocoa Touch对象（例如NSMutableArray）定义，在这种情况下，编译器不会发出警告，但这段代码会在运行时生成异常，因为NSString对象无法响应<code>removeAllObjects</code>。</p><p>将代码重写为使用静态类型：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>NSString <span class="token operator">*</span>someObject <span class="token operator">=</span> <span class="token string">@&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>someObject removeAllObjects<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种情况下编译器将会报错，因为它无法在任何公共NSString接口中找到removeAllObjects\`声明。</p><p>因为<strong>对象的类是在运行时确定的</strong>，所以在创建或处理实例时，分配变量的类型是无关紧要的。要使用本章前面描述的XYZPerson和XYZShoutingPerson类，您可以使用以下代码：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>XYZPerson <span class="token operator">*</span>firstPerson <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>XYZPerson alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
XYZPerson <span class="token operator">*</span>secondPerson <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>XYZShoutingPerson alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>firstPerson sayHello<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>secondPerson sayHello<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尽管<code>firstPerson</code>和<code>secondPerson</code>都被静态类型化为XYZPerson对象，但<code>secondPerson</code>将在运行时指向XYZShoutingPerson对象。当在每个对象上调用<code>sayHello</code>方法时，都将使用逻辑上正确的实现；对于<code>secondPerson</code>，这意味着使用XYZShoutingPerson版本。</p><h3 id="determining-equality-of-objects-确定对象的相等性" tabindex="-1"><a class="header-anchor" href="#determining-equality-of-objects-确定对象的相等性" aria-hidden="true">#</a> Determining Equality of Objects <strong>确定对象的相等性</strong></h3><p>如果需要确定一个对象是否与另一个对象相同，重要的是要记住<strong>你在使用指针</strong>。</p><p>标准的C等号运算符<code>==</code>用于测试两个变量的值之间的相等性，就像这样：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>someInteger <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// someInteger 的值为 42</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在处理对象时，<code>==</code>运算符用于测试两个不同的指针是<strong>否指向同一个对象</strong>：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstPerson <span class="token operator">==</span> secondPerson<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// firstPerson is the same object as secondPerson</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要测试两个对象是否表示<strong>相同的数据</strong>，您需要调用<code>isEqual:</code>这样的方法，这是NSObject提供的：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>firstPerson isEqual<span class="token punctuation">:</span>secondPerson<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// firstPerson is identical to secondPerson</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要比较一个对象是否表示大于或小于另一个对象的值，您不能使用标准的C比较运算符<code>&gt;</code>和<code>&lt;</code>。相反，基本的Foundation类型，如NSNumber，NSString和NSDate，提供了一个<code>compare:</code>方法：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>someDate compare<span class="token punctuation">:</span>anotherDate<span class="token punctuation">]</span> <span class="token operator">==</span> NSOrderedAscending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// someDate is earlier than anotherDate</span>
    <span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="working-with-nil-处理nil" tabindex="-1"><a class="header-anchor" href="#working-with-nil-处理nil" aria-hidden="true">#</a> Working with nil <strong>处理nil</strong></h3><p>始终在声明时<strong>初始化变量是一个好主意</strong>，否则它们的初始值将包含来自当前栈中的垃圾：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>    BOOL success <span class="token operator">=</span> NO<span class="token punctuation">;</span>
    <span class="token keyword">int</span> magicNumber <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这对于<strong>对象指针是不必要的</strong>，因为如果您没有指定任何其他初始值，编译器会<strong>自动</strong>将变量设置为<code>nil</code>：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code>    XYZPerson <span class="token operator">*</span>somePerson<span class="token punctuation">;</span>
    <span class="token comment">// somePerson is automatically set to nil</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果没有其他值可用，<code>nil</code>值是初始化对象指针的最安全方式，因为在Objective-C中，向<code>nil</code>发送消息是完全可以接受的。如果向<code>nil</code>发送消息，显然什么都不会发生。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>注意：如果您期望从发送到\`nil\`的消息中得到返回值，
对于对象返回类型，返回值将为\`nil\`，
对于数值类型，返回值将为0，
对于\`BOOL\`类型，返回值将为\`NO\`。
返回的结构具有所有成员初始化为零。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要检查对象不是<code>nil</code>（即变量指向内存中的对象），您可以使用标准的C不等号运算符：</p><div class="language-objc line-numbers-mode" data-ext="objc"><pre class="language-objc"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>somePerson <span class="token operator">!=</span> nil<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// somePerson 指向一个对象</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>somePerson<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// somePerson 指向一个对象</span>
<span class="token punctuation">}</span>
<span class="token comment">//如果somePerson变量为nil，它的逻辑值为0（假）。如果它有一个地址，它不是零，因此计算为真。</span>

<span class="token comment">//同样，如果需要检查是否为nil变量，可以使用等号运算符：</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>somePerson <span class="token operator">==</span> nil<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// somePerson 不指向一个对象</span>
<span class="token punctuation">}</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>somePerson<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// somePerson does not point to an object</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,31);function C(x,P){const i=o("RouterLink"),t=o("ExternalLinkIcon");return p(),l("div",null,[d,m,s("p",null,[a(i,{to:"/tec/basic/programWithOC/%E6%96%87%E7%AB%A0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"},{default:r(()=>[n("上一章")]),_:1}),n("描述了定义类的接口和实现的语法，包括实现响应消息的方法的代码的语法。本章解释了如何向对象发送这样的消息，并介绍了一些Objective-C的"),v,n("，包括动态类型"),k,n("和能够在运行时确定实际应调用哪个方法的能力。")]),b,s("p",null,[s("a",g,[n("String Format Specifiers"),a(t)]),n(" 字符串格式说明符")]),h,s("p",null,[n("请注意，此方法的返回类型是id。这是Objective-C中用来表示“某种对象”的特殊关键字。"),j,n("，如（NSObject *），"),S,n("。更多关于id的信息将在本章后面的“ "),s("a",y,[n("Objective-C Is a Dynamic Language"),a(t)]),n(" Objective-C是一种动态语言”中详细描述。")]),f,s("p",null,[n("Objective-C还支持使用"),N,n("来创建不可变的NSArray和NSDictionary对象；这些将在“数值和集合 "),s("a",w,[n("Values and Collections"),a(t)]),n("”中进一步讨论。")]),O])}const X=c(u,[["render",C],["__file","workWithObject.html.vue"]]);export{X as default};
