import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as s,c,b as t,d as e,a as n,f as i}from"./app-379d8127.js";const d={},l=i('<h1 id="runtime" tabindex="-1"><a class="header-anchor" href="#runtime" aria-hidden="true">#</a> Runtime</h1><h2 id="引子" tabindex="-1"><a class="header-anchor" href="#引子" aria-hidden="true">#</a> 引子</h2><p>学到OC，看到的文章中隐约中提到了OC的所谓“函数调用”其实是向持有类/实例发送消息从而达到调用效果，进一步了解OC的内存管理机制后，发现不同于C++，OC的内存管理有ARC、自动释放池这些“魔法”机制，而这些机制的又建立在这个神秘的Runtime机制上。</p><h4 id="receiver-message-发送消息" tabindex="-1"><a class="header-anchor" href="#receiver-message-发送消息" aria-hidden="true">#</a> [receiver message]发送消息</h4><p>我们知道OC的底层是由C/C++实现的，而对于编译器来说方括号的实现则是以以下形式</p><p><code>bjc_msgSend(receiver, selector)//不带参数</code></p><p><code>objc_msgSend(receiver, selector, arg1, arg2, ...)//带参数，可以发现是</code></p><p>参考文章：</p>',8),u={href:"https://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/",target:"_blank",rel:"noopener noreferrer"},m=t("p",null,"杨老师基本上翻译了苹果的文章，加上的自己的理解，省略了一些内容",-1),p={href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1",target:"_blank",rel:"noopener noreferrer"},g=i(`<p>苹果这篇来自2009年的文章看的头疼，建议把侧栏关了然后放大看。Google翻译的稀烂，还得是看原文自己来。</p><h2 id="为什么要引入runtime机制" tabindex="-1"><a class="header-anchor" href="#为什么要引入runtime机制" aria-hidden="true">#</a> 为什么要引入Runtime机制</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work。 —— 摘自苹果官方文档
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Objective-C 语言将尽可能多的决策从编译时和链接时<strong>推迟到运行时</strong>。只要有可能，它就会<strong>动态</strong>地执行操作。这意味着该语言不仅需要编译器，还需要运行时系统来执行编译后的代码。Runtime机制某种程度上充当了该语言的操作系统，让这门语言能够运作起来。</p><h2 id="与runtime交互" tabindex="-1"><a class="header-anchor" href="#与runtime交互" aria-hidden="true">#</a> 与Runtime交互</h2><p>与Runtime系统的交互可以分为三个级别</p><ul><li>通过源代码</li><li>通过类方法（来自Foundation 框架的NSObject类）</li><li>对runtime函数直接调用</li></ul><h3 id="源代码交互" tabindex="-1"><a class="header-anchor" href="#源代码交互" aria-hidden="true">#</a> 源代码交互</h3><p><code>“在大部分时候,Runtime系统都自动地运行在幕后，你只需要编写和编译OC”</code></p><p>OC的编译器会为OC类和方法创造【符合动态特性的】数据结构以及方法</p><ul><li>数据结构会捕获类以及类的Category（分类）的定义、协议（Protocols）的声明以及方法选择器、实例变量模板以及其他来自源代码的信息</li><li>最重要的runtime函数就是<strong>发送消息</strong>的函数<code>Messaging</code></li></ul>`,11);function _(b,f){const a=o("ExternalLinkIcon");return s(),c("div",null,[l,t("p",null,[e("["),t("a",u,[e("Objective-C Runtime"),n(a)]),e("]("),t("a",h,[e("https://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/"),n(a)]),e(")")]),m,t("p",null,[t("a",p,[e("Objective-C Runtime Programming Guide"),n(a)])]),g])}const x=r(d,[["render",_],["__file","Runtime.html.vue"]]);export{x as default};
