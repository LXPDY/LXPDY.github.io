import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as l,f as d}from"./app-109d473d.js";const o={},c=d('<h1 id="git原理及实用技巧" tabindex="-1"><a class="header-anchor" href="#git原理及实用技巧" aria-hidden="true">#</a> Git原理及实用技巧</h1><h2 id="git的储存原理" tabindex="-1"><a class="header-anchor" href="#git的储存原理" aria-hidden="true">#</a> Git的储存原理</h2><p>当你使用<code>git init</code>创建在一个目录创建一个本地仓库后，会在目录下生成一个<code>.git</code>文件夹，而这个文件夹就是git相关的数据库。</p><h4 id="当你进行本地修改-git-add-commit-push时-本地发生了什么" tabindex="-1"><a class="header-anchor" href="#当你进行本地修改-git-add-commit-push时-本地发生了什么" aria-hidden="true">#</a> 当你进行<code>本地修改-git add - commit - push</code>时，本地发生了什么？</h4><ul><li><code>git add a.txt</code>加入到暂存区 <ul><li><code>.git/objects</code>下新生成了一个文件(<code>object</code>)，其中存储了我们新添加文件到<strong>哈希值</strong><ul><li>该哈希值一般使用前6位即可，后置位为冗余</li><li>使用命令<code>git cat-file -t</code>查看类型，<code>git cat-file -p</code>查看内容</li><li>在这个情况下，生成的类型查看为<code>blob</code></li></ul></li></ul></li><li><code>git commit -m &#39;init&#39;</code><ul><li><code>.git/objects</code>下新生成了一系列<code>object</code><ul><li>对于类型为<code>tree</code>的，其内容为文件快照，包括<code>文件权限 文件类型 文件哈希值 文件名</code>的列表</li><li>对于类型为<code>commit</code>的，其内容为<strong>项目快照</strong>，包括作者信息、提交时间和其他提交信息</li></ul></li></ul></li></ul><p>Git就是通过这样的哈希值作为指针，来对文件进行管理。</p><ul><li>对于上面的例子，也就是生成了对应<code>blob object</code>储存内容，又生成了一个<code>tree object</code>来储存目录的快照，然后通过一个<code>commit object</code>来存储提交的信息，并且它们的信息都是通过哈希值作为指针去指向的。</li></ul><p>对于当前分支，git在HEAD文件中明文储存，明文指向一个文件，文件中储存着哈希值，指向上一个<code>commit object</code></p><h2 id="可视化git操作" tabindex="-1"><a class="header-anchor" href="#可视化git操作" aria-hidden="true">#</a> 可视化Git操作</h2><p>综合以上存储结构，git形成了一个有向无环图，也就是一颗哈希树/DAG，树根为HEAD，也就是指向当前分支的<code>refs</code>指针,树叶为<code>blob object</code></p><ul><li><code>Git object</code>(blob tree commit) 只要文件不被修改，就可以被复用，但是其本身不允许变更</li><li><code>refs</code>指针可以被修改</li><li>采用<code>tree object</code>储存文件名，可以非常方便地复用<code>blob object</code></li><li>若<code>blob object</code>的内容发生改变，其哈希值也发生改变，又由于git分布式的特性，即使能够修改一台机器上的所有对应哈希值，也无法改变其他机器上的内容，所以git不会被轻易篡改</li></ul><h4 id="git的三个分区" tabindex="-1"><a class="header-anchor" href="#git的三个分区" aria-hidden="true">#</a> Git的三个分区</h4><ul><li>工作目录（working directory） <ul><li><strong>操作系统上的文件</strong>，所有代码开发编辑都在这上面完成</li></ul></li><li>索引（index or staging area） <ul><li>一个暂存区域，会在下一次commit被提交到Git仓库</li><li>是<code>tree object</code></li></ul></li><li>Git仓库（git repository） <ul><li>由<code>Git object</code>记录着每一次提交到快照，以及链式结构记录的提交变更历史</li></ul></li></ul><p>但是，由于每次都生成新的文件快照，是否会影响性能？</p><ul><li>新快照对比存储变更，能够快速获取读取</li><li>对于空间，Git拥有一套<code>git gc</code>机制，会在空间太大或者网络请求时将变更部分压缩成pack</li></ul><p><code>git reset</code></p><ul><li><code>--soft HEAD~</code>只更改HEAD指针到上一个commit版本</li><li><code>[--mixed] HEAD~</code>更改HEAD指针到上一个commit版本,并修改index</li><li><code>--hard HEAD~</code>更改HEAD指针到上一个commit版本,修改index和工作区</li></ul><h2 id="分支合并" tabindex="-1"><a class="header-anchor" href="#分支合并" aria-hidden="true">#</a> 分支合并</h2><ul><li>举个分支合并造成文件缺失导致bug的例子 <ul><li>A&lt;-C&lt;-E&lt;-E&#39;(master) ;A&lt;-B&lt;-D <ul><li>小明在A的分支B上进行开发，添加了一个文件http.js，然后合并进入C形成E</li><li>E有bug，回滚为E&#39;</li><li>小明在B的基础上继续开发,添加了main,js，import了http.js，然后尝试将D合并到master上</li><li>合并没有报错，尝试运行master分支，发现缺少了http.js这个文件无法运行</li></ul></li><li>合并前文件还在，合并后不见了</li></ul></li></ul><h4 id="如何合并两个文件内容" tabindex="-1"><a class="header-anchor" href="#如何合并两个文件内容" aria-hidden="true">#</a> 如何合并两个文件内容</h4><ul><li><p>Three-way merge 三向合并</p><ul><li><img src="https://marsishandsome.github.io/images/2019-7-24-Three_Way_Merge/three-way.png" alt="three-way" style="zoom:50%;"></li><li><p><code>Three-way merge</code>是在<code>Two-way merge</code>的基础上又增加了一个信息，即两个需要合并的文件修改前的版本。如下图所示，merge算法现在知道三个信息：</p><ul><li><code>Mine</code>：需要合并的一个文件</li><li><code>Yours</code>：另一个需要合并的文件</li><li><code>Base</code>：两个文件修改前的版本</li></ul></li><li><p>引入三向合并，Git就能知道哪些部分修改了，哪些部分添加了，哪些部分冲突了（三向都不一样）</p></li></ul></li></ul><h4 id="git-merge策略" tabindex="-1"><a class="header-anchor" href="#git-merge策略" aria-hidden="true">#</a> Git merge策略</h4><ul><li><code>Fast-forward</code><ul><li>对于两天没有分叉的分支的默认行为</li><li>使用<code>-no-ff</code>关闭</li></ul></li><li><code>Recursive</code>**（重点）**递归合并 <ul><li>找到最短路径的共同祖先节点作为base节点，然后做三向合并</li><li>在复杂情况下，若出现多个同路径长的祖先节点（A和B） <ul><li>则继续对同路径长的祖先节点进行递归查找，直到找到唯一共同祖先</li><li>使用这个共同祖先，对A和B进行合并，获得一个临时节点C</li><li>再向上做三向合并，直到合并完成</li></ul></li></ul></li><li><code>Ours</code>/<code>Theirs</code><ul><li>只用一个分支的内容</li></ul></li><li><code>Octopus</code><ul><li>多分支合并时使用</li><li>多在测试时使用</li></ul></li></ul><p>正常情况下，Git会自动选择最合适的策略，若需要手动选择，则使用如下命令</p><ul><li><code>git merge -s [策略名]</code></li></ul><p><code>git rebase</code></p><ul><li>会生成一个新的<code>commit object</code>节点</li><li><code>git rebase -i [commit节点]</code><ul><li>使用后可以修改之前的提交记录、做压缩</li></ul></li></ul><h4 id="rebase-or-merge" tabindex="-1"><a class="header-anchor" href="#rebase-or-merge" aria-hidden="true">#</a> rebase or merge</h4><ul><li>merge会保留完整的分支情况、真实commit时间等等</li><li>rebase则可以调整出清晰的代码修改历史记录</li><li>可以根据团队习惯来选择更合适的方法</li><li>但是有一点需要注意：<strong>不可以对已经处于远端的分支做rebase</strong></li><li>前辈的习惯 <ul><li>在自己本地或者是确定只有一个人使用的分支下，使用rebase</li><li>其他情况使用merge</li></ul></li></ul><h2 id="git实用技巧" tabindex="-1"><a class="header-anchor" href="#git实用技巧" aria-hidden="true">#</a> Git实用技巧</h2><h4 id="误操作导致分支不见了-如何恢复" tabindex="-1"><a class="header-anchor" href="#误操作导致分支不见了-如何恢复" aria-hidden="true">#</a> 误操作导致分支不见了，如何恢复</h4><ul><li><p>使用<code>git reflog master</code>查看master指针指过的地方</p><ul><li>也就是版本控制的版本控制</li></ul></li><li><p>寻找对应节点的哈希值，使用git reset还原</p></li></ul><h4 id="获得干净的工作目录" tabindex="-1"><a class="header-anchor" href="#获得干净的工作目录" aria-hidden="true">#</a> 获得干净的工作目录</h4><p><code>git -reset --hard HEAD</code></p><p><code>git checkout -f</code></p><p>这两个都会导致丢失文件</p><p>建议：使用<code>git stash push [-u]</code></p><h4 id="禁止修改远端分支的历史" tabindex="-1"><a class="header-anchor" href="#禁止修改远端分支的历史" aria-hidden="true">#</a> 禁止修改远端分支的历史</h4><p>若发生了修改远端分支的历史，如何解决（这里用到了上面说过的合并问题的例子）</p><p><code>git cherry-pick E</code>//在master分支把E这个提交应用到master分支上</p><p>或</p><p><code>git rebase --onto C&#39; C E</code>//在C&#39;上把C-E的commit合并</p><h4 id="撤销一个本地合并" tabindex="-1"><a class="header-anchor" href="#撤销一个本地合并" aria-hidden="true">#</a> 撤销一个本地合并</h4><p>使用<code>git reset</code></p><h4 id="撤销一个远端合并" tabindex="-1"><a class="header-anchor" href="#撤销一个远端合并" aria-hidden="true">#</a> 撤销一个远端合并</h4><p><code>git revert -m 1 E</code>//新建一个节点回滚</p><h4 id="从历史中删除一个文件" tabindex="-1"><a class="header-anchor" href="#从历史中删除一个文件" aria-hidden="true">#</a> 从历史中删除一个文件</h4><p>敏感信息、不需要版本控制的超大文件</p><p><code>git filter -branch --tree-filter &#39;rm -f password.txt&#39; HEAD</code></p><p>高危操作，需要所有人一起</p><h4 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h4><ul><li><code>git commit --amend</code><ul><li>用新的commit覆盖你上次的commit</li></ul></li><li><code>git show-branch</code><ul><li>快捷查看分支</li></ul></li><li><code>git blame</code><ul><li>看看代码是谁写的</li><li><s>用于甩锅</s></li></ul></li><li><code>git bisect</code><ul><li>通过二分查找寻找出问题的那个commit</li></ul></li></ul>',52),t=[c];function a(r,h){return i(),l("div",null,t)}const n=e(o,[["render",a],["__file","index.html.vue"]]);export{n as default};
